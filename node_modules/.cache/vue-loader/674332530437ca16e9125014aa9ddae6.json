{"remainingRequest":"/home/falcon-puneet/Documents/Arbunize/videowiki/video-wiki-frontend/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/falcon-puneet/Documents/Arbunize/videowiki/video-wiki-frontend/src/views/pages/PublishVideo.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/falcon-puneet/Documents/Arbunize/videowiki/video-wiki-frontend/src/views/pages/PublishVideo.vue","mtime":1617441641275},{"path":"/home/falcon-puneet/Documents/Arbunize/videowiki/video-wiki-frontend/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/falcon-puneet/Documents/Arbunize/videowiki/video-wiki-frontend/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/falcon-puneet/Documents/Arbunize/videowiki/video-wiki-frontend/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/falcon-puneet/Documents/Arbunize/videowiki/video-wiki-frontend/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport constants from '../../../constant';\nimport axios from 'axios';\nimport Transaction from '@/views/components/Transaction/Transaction.vue';\nimport { mapState } from 'vuex';\n\nexport default {\n  name: 'PublishVideo',\n  components: {\n    Transaction\n  },\n  data() {\n    return {\n      player: null,\n      videos: [],\n      indexs: 0,\n      constants,\n      // showAlert: false,\n      saveForLater: false,\n      task_id: null,\n      videoId: null,\n      downloadInProgress: false,\n      showTransactionModal: false,\n      currentTxPhase: 'Processing',\n      previewReq: Function\n    };\n  },\n  computed: {\n    ...mapState('auth', ['isUserLoggedIn']),\n    getVideoLink() {\n      return this.$store.state.studio.previewVideo;\n    },\n    getFilename() {\n      return `${this.$store.state.studio.video.title}_videowiki.mp4`;\n    },\n    /* isPublished() {\n      return this.$store.state.studio.publishStatus;\n    }, */\n    isPaid() {\n      return this.$store.state.studio.video.isPaid;\n    },\n    totalScenes() {\n      return Object.keys(this.$store.state.studio.scenes).length;\n    },\n    sceneTransitionList() {\n      return this.$store.state.studio.sceneTransition;\n    },\n    insideIframe() {\n      return this.$store.state.insideIframe;\n    }\n  },\n  mounted() {\n    if (this.$route.params.videoId) {\n      this.videoId = this.$route.params.videoId;\n    }\n    if (this.getVideoLink) {\n      this.$vs.dialog({\n        type: 'confirm',\n        color: 'primary',\n        title: `Confirm`,\n        acceptText: 'Yes',\n        text: 'Do you want to generate the Preview again ?',\n        accept: this.collectVideos\n      });\n    } else {\n      this.collectVideos();\n    }\n  },\n  methods: {\n    collectVideos() {\n      this.$store.commit('studio/setPreviewVideo', null);\n      this.$vs.loading({\n        background: '#fff',\n        container: '#preview-loading',\n        text: 'Generating Preview...'\n      });\n      const libraryItems = this.$store.state.studio.selectedFromLibraryVideos;\n      const preparedScene = this.$store.state.studio.preparedScenesVideos;\n      const audioVideo = this.$store.state.studio.addedAudioVideos;\n      for (let i = 1; i <= this.totalScenes; i++) {\n        if (audioVideo[i]) this.videos.push(audioVideo[i]);\n        else if (preparedScene[i]) this.videos.push(preparedScene[i]);\n        else if (libraryItems[i]) this.videos.push(libraryItems[i]);\n      }\n      this.concatVideos();\n    },\n    async concatVideos() {\n      const videoData = {\n        videos: this.videos,\n        task_id: this.task_id,\n        isPreview: 1,\n        motions: this.sceneTransitionList,\n        bgm: this.$store.state.studio.backgroundMusic.url || null\n      };\n      try {\n        const apiResponse = await this.$store.dispatch(\n          'studio/concatenateVideos',\n          videoData\n        );\n        console.log(apiResponse);\n        if (!this.task_id) this.task_id = apiResponse.task_id;\n        if (apiResponse.status) {\n          this.$store.commit(\n            'studio/setPreviewVideo',\n            apiResponse.data.video_url\n          );\n          this.$store.commit('studio/SET_VIDEO_ATTR', {\n            key: 'image',\n            value: apiResponse.data.image_url\n          });\n          // this.$Progress.finish();\n          this.$vs.loading.close('#preview-loading > .con-vs-loading');\n          /* this.$vs.loading({\n            background: '#fff',\n            container: '#preview-loading',\n            text: 'Preparing your video..',\n          });\n          const previewVideo = document.getElementById('preview_video');\n          previewVideo.oncanplaythrough = () => {\n            this.$vs.loading.close('#preview-loading > .con-vs-loading');\n          }; */\n        } else {\n          this.previewReq = setTimeout(() => this.concatVideos(), 15000);\n        }\n      } catch (err) {\n        // this.$Progress.fail();\n        this.$vs.loading.close('#preview-loading > .con-vs-loading');\n        this.$vs.notify({\n          title: 'Error',\n          text: 'Merge Failed',\n          color: 'danger'\n        });\n      }\n    },\n    getUserName() {\n      const userInfo = this.$store.state.AppActiveUser;\n      return userInfo.username;\n    },\n    handlePublish() {\n      this.saveForLater = false;\n      this.handleVideoSubmit();\n    },\n    handleSaveForLater() {\n      this.saveForLater = true;\n      this.handleVideoSubmit();\n    },\n    async handleVideoSubmit() {\n      if (this.isUserLoggedIn()) {\n        const title = this.$store.state.studio.video.title;\n        const desc = this.$store.state.studio.video.description;\n        if (title !== '' && desc !== '') {\n          // this.submitVideo(saveLater);\n          if (this.isPaid) {\n            if (this.$store.state.isWalletConnected) {\n              const payload = {\n                author: this.getUserName(),\n                metaData: {\n                  url: this.getVideoLink,\n                  title: title\n                }\n              };\n              this.$store.commit('SET_CURRENT_TRANSACTION_STEP', 1);\n              this.currentTxPhase = 'Processing';\n              this.showTransactionModal = true;\n              try {\n                await this.$store.dispatch('publishToOcean', payload);\n                setTimeout(() => {\n                  this.showTransactionModal = false;\n                  this.submitVideo();\n                }, 2000);\n              } catch (error) {\n                if (error.code === 4001) this.currentTxPhase = 'Rejected';\n                else this.currentTxPhase = 'Failed';\n              }\n            } else {\n              this.$vs.notify({\n                text: 'Connect your Wallet First',\n                color: 'primary'\n              });\n            }\n          } else {\n            this.submitVideo();\n          }\n        } else {\n          this.$vs.notify({\n            title: 'Input Missing',\n            text: 'Title/Description cannot be empty',\n            color: 'primary'\n          });\n        }\n      } else {\n        this.$store.commit('TOGGLE_LOGIN_POPUP', true);\n      }\n    },\n    submitVideo() {\n      this.$Progress.start();\n      this.$vs.loading({ color: 'transparent' });\n      const video = this.$store.state.studio.video;\n      const metaData = this.$store.state.studio;\n      const sceneData = this.getSceneData(metaData);\n      const data = {\n        info: {\n          title: video.title,\n          description: video.description,\n          image: video.image,\n          script: metaData.videoScript,\n          url: video.url,\n          user: this.getUserName(),\n          duration: document.getElementById('preview_video').duration,\n          language: video.srcLang\n        },\n        id: this.videoId,\n        published_id: video.published_id,\n        scenes: sceneData,\n        bgm: metaData.backgroundMusic.url || null,\n        video: metaData.previewVideo,\n        is_save_later: this.saveForLater,\n        tags: metaData.tags\n      };\n      console.log(data);\n      /* Ajax call start */\n      this.$store\n        .dispatch('studio/publishVideo', data)\n        .then(res => {\n          if (!this.saveForLater) {\n            if (this.isPaid) {\n              const payload = {\n                exchange_key: video.txData.exchangeId,\n                dod: video.txData.did,\n                dataToken: video.txData.dataTokenAddress,\n                paid: video.isPaid,\n                video_id: res.data.id\n              };\n              this.$store\n                .dispatch('studio/postTxData', payload)\n                .then(() => {\n                  this.$Progress.finish();\n                  this.$vs.loading.close();\n                  this.$router.push('/dashboard');\n                  this.$vs.notify({\n                    title: 'Success',\n                    text: 'Video Published Successfully',\n                    color: 'success'\n                  });\n                })\n                .catch(err => {\n                  console.log(err);\n                  this.$Progress.fail();\n                  this.$vs.loading.close();\n                  this.$vs.notify({\n                    title: 'Error',\n                    text: 'Video Tx data was not saved',\n                    color: 'danger'\n                  });\n                });\n              return;\n            }\n            this.$Progress.finish();\n            this.$vs.loading.close();\n            this.$router.push('/dashboard');\n            this.$vs.notify({\n              title: 'Success',\n              text: 'Video Published Successfully',\n              color: 'success'\n            });\n          } else {\n            this.$Progress.finish();\n            this.$vs.loading.close();\n            this.$router.push('/myvideos');\n            this.$vs.notify({\n              title: 'Success',\n              text: 'Video Saved Successfully',\n              color: 'success'\n            });\n          }\n        })\n        .catch(err => {\n          console.log(err);\n          this.$Progress.fail();\n          this.$vs.loading.close();\n          this.$vs.notify({\n            title: 'Error',\n            text: this.saveForLater\n              ? 'Video was not saved'\n              : 'Video was not published',\n            color: 'danger'\n          });\n        });\n      /* Ajax call end */\n    },\n    getSceneData(metaData) {\n      const scenes = {};\n      Object.entries(metaData.scenes).forEach(([key, value]) => {\n        const {\n          sceneScriptColor: font_color,\n          sceneScriptPosition: position,\n          sceneBackgroundColor: background_color\n        } = metaData.styles[key];\n\n        scenes[key] = {\n          text: value,\n          keywords: metaData.keywords[key],\n          online_url: null,\n          audio: null,\n          uploaded_video: null,\n          position: position.toString(),\n          font_color,\n          background_color\n        };\n        // audio url\n        if (metaData.recordedAudios[key]) {\n          const audioUrl = metaData.recordedAudios[key];\n          scenes[key].audio = audioUrl.search('blob:') === -1 ? audioUrl : null;\n        }\n        // video url\n        if (metaData.selectedFromLibraryVideos[parseInt(key) + 1]) {\n          const videoUrl = new URL(\n            metaData.selectedFromLibraryVideos[parseInt(key) + 1]\n          );\n          if (videoUrl.origin === constants.apiUrl)\n            scenes[key].uploaded_video = videoUrl.href;\n          else scenes[key].online_url = videoUrl.href;\n        }\n      });\n      return scenes;\n    },\n    handleDownload() {\n      this.downloadInProgress = true;\n      this.$vs.loading({\n        background: 'primary',\n        color: '#fff',\n        container: '#download-with-loading',\n        scale: 0.45\n      });\n      axios\n        .get(this.getVideoLink, { responseType: 'blob' })\n        .then(response => {\n          const blob = new Blob([response.data], { type: 'video/mp4' });\n          const link = document.createElement('a');\n          link.href = URL.createObjectURL(blob);\n          link.download = this.getFilename;\n          link.click();\n          URL.revokeObjectURL(link.href);\n        })\n        .catch(() => {\n          this.$vs.notify({\n            title: 'Error Occured',\n            text: 'Download Failed',\n            color: 'danger'\n          });\n        })\n        .finally(() => {\n          this.downloadInProgress = false;\n          this.$vs.loading.close('#download-with-loading > .con-vs-loading');\n        });\n    }\n  },\n  beforeDestroy() {\n    clearTimeout(this.previewReq);\n  }\n};\n",{"version":3,"sources":["PublishVideo.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoDA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"PublishVideo.vue","sourceRoot":"src/views/pages","sourcesContent":["<template>\n  <div>\n    <vx-card class=\"scene-card vs-con-loading__container\" id=\"preview-loading\">\n      <h4 class=\"text-center mb-4\">Preview</h4>\n      <p class=\"font-semibold items-left mb-base\" style=\"white-space: normal\">\n        Note: This is a low quality video for rendering purposes only, when your\n        are ready, extract a high quality video by publishing it.\n      </p>\n      <video\n        width=\"100%\"\n        height=\"auto\"\n        :src=\"getVideoLink\"\n        id=\"preview_video\"\n        controls\n      >\n        {{ $t('studio.errors.e1') }}\n      </video>\n      <div class=\"mb-base\"></div>\n      <div class=\"flex justify-center\">\n        <vs-button\n          @click=\"handlePublish\"\n          class=\"bg-custom-purple mr-4\"\n          v-if=\"!insideIframe\"\n          >{{ $t('studio.publish.p1') }}</vs-button\n        >\n        <!--vs-button\n          class=\"bg-custom-purple mr-4\"\n          @click.prevent=\"handleSaveForLater\"\n          >Save Draft</vs-button\n        -->\n\n        <vs-button\n          class=\"bg-custom-purple px-4 vs-con-loading__container\"\n          id=\"download-with-loading\"\n          icon=\"get_app\"\n          :disabled=\"downloadInProgress\"\n          @click.prevent=\"handleDownload\"\n          >Download</vs-button\n        >\n      </div>\n    </vx-card>\n    <Transaction\n      :show=\"showTransactionModal\"\n      transactionType=\"Publish\"\n      :transactionPhase=\"currentTxPhase\"\n      @close=\"showTransactionModal = false\"\n      @retry=\"handlePublish\"\n    />\n  </div>\n</template>\n\n<script>\nimport constants from '../../../constant';\nimport axios from 'axios';\nimport Transaction from '@/views/components/Transaction/Transaction.vue';\nimport { mapState } from 'vuex';\n\nexport default {\n  name: 'PublishVideo',\n  components: {\n    Transaction\n  },\n  data() {\n    return {\n      player: null,\n      videos: [],\n      indexs: 0,\n      constants,\n      // showAlert: false,\n      saveForLater: false,\n      task_id: null,\n      videoId: null,\n      downloadInProgress: false,\n      showTransactionModal: false,\n      currentTxPhase: 'Processing',\n      previewReq: Function\n    };\n  },\n  computed: {\n    ...mapState('auth', ['isUserLoggedIn']),\n    getVideoLink() {\n      return this.$store.state.studio.previewVideo;\n    },\n    getFilename() {\n      return `${this.$store.state.studio.video.title}_videowiki.mp4`;\n    },\n    /* isPublished() {\n      return this.$store.state.studio.publishStatus;\n    }, */\n    isPaid() {\n      return this.$store.state.studio.video.isPaid;\n    },\n    totalScenes() {\n      return Object.keys(this.$store.state.studio.scenes).length;\n    },\n    sceneTransitionList() {\n      return this.$store.state.studio.sceneTransition;\n    },\n    insideIframe() {\n      return this.$store.state.insideIframe;\n    }\n  },\n  mounted() {\n    if (this.$route.params.videoId) {\n      this.videoId = this.$route.params.videoId;\n    }\n    if (this.getVideoLink) {\n      this.$vs.dialog({\n        type: 'confirm',\n        color: 'primary',\n        title: `Confirm`,\n        acceptText: 'Yes',\n        text: 'Do you want to generate the Preview again ?',\n        accept: this.collectVideos\n      });\n    } else {\n      this.collectVideos();\n    }\n  },\n  methods: {\n    collectVideos() {\n      this.$store.commit('studio/setPreviewVideo', null);\n      this.$vs.loading({\n        background: '#fff',\n        container: '#preview-loading',\n        text: 'Generating Preview...'\n      });\n      const libraryItems = this.$store.state.studio.selectedFromLibraryVideos;\n      const preparedScene = this.$store.state.studio.preparedScenesVideos;\n      const audioVideo = this.$store.state.studio.addedAudioVideos;\n      for (let i = 1; i <= this.totalScenes; i++) {\n        if (audioVideo[i]) this.videos.push(audioVideo[i]);\n        else if (preparedScene[i]) this.videos.push(preparedScene[i]);\n        else if (libraryItems[i]) this.videos.push(libraryItems[i]);\n      }\n      this.concatVideos();\n    },\n    async concatVideos() {\n      const videoData = {\n        videos: this.videos,\n        task_id: this.task_id,\n        isPreview: 1,\n        motions: this.sceneTransitionList,\n        bgm: this.$store.state.studio.backgroundMusic.url || null\n      };\n      try {\n        const apiResponse = await this.$store.dispatch(\n          'studio/concatenateVideos',\n          videoData\n        );\n        console.log(apiResponse);\n        if (!this.task_id) this.task_id = apiResponse.task_id;\n        if (apiResponse.status) {\n          this.$store.commit(\n            'studio/setPreviewVideo',\n            apiResponse.data.video_url\n          );\n          this.$store.commit('studio/SET_VIDEO_ATTR', {\n            key: 'image',\n            value: apiResponse.data.image_url\n          });\n          // this.$Progress.finish();\n          this.$vs.loading.close('#preview-loading > .con-vs-loading');\n          /* this.$vs.loading({\n            background: '#fff',\n            container: '#preview-loading',\n            text: 'Preparing your video..',\n          });\n          const previewVideo = document.getElementById('preview_video');\n          previewVideo.oncanplaythrough = () => {\n            this.$vs.loading.close('#preview-loading > .con-vs-loading');\n          }; */\n        } else {\n          this.previewReq = setTimeout(() => this.concatVideos(), 15000);\n        }\n      } catch (err) {\n        // this.$Progress.fail();\n        this.$vs.loading.close('#preview-loading > .con-vs-loading');\n        this.$vs.notify({\n          title: 'Error',\n          text: 'Merge Failed',\n          color: 'danger'\n        });\n      }\n    },\n    getUserName() {\n      const userInfo = this.$store.state.AppActiveUser;\n      return userInfo.username;\n    },\n    handlePublish() {\n      this.saveForLater = false;\n      this.handleVideoSubmit();\n    },\n    handleSaveForLater() {\n      this.saveForLater = true;\n      this.handleVideoSubmit();\n    },\n    async handleVideoSubmit() {\n      if (this.isUserLoggedIn()) {\n        const title = this.$store.state.studio.video.title;\n        const desc = this.$store.state.studio.video.description;\n        if (title !== '' && desc !== '') {\n          // this.submitVideo(saveLater);\n          if (this.isPaid) {\n            if (this.$store.state.isWalletConnected) {\n              const payload = {\n                author: this.getUserName(),\n                metaData: {\n                  url: this.getVideoLink,\n                  title: title\n                }\n              };\n              this.$store.commit('SET_CURRENT_TRANSACTION_STEP', 1);\n              this.currentTxPhase = 'Processing';\n              this.showTransactionModal = true;\n              try {\n                await this.$store.dispatch('publishToOcean', payload);\n                setTimeout(() => {\n                  this.showTransactionModal = false;\n                  this.submitVideo();\n                }, 2000);\n              } catch (error) {\n                if (error.code === 4001) this.currentTxPhase = 'Rejected';\n                else this.currentTxPhase = 'Failed';\n              }\n            } else {\n              this.$vs.notify({\n                text: 'Connect your Wallet First',\n                color: 'primary'\n              });\n            }\n          } else {\n            this.submitVideo();\n          }\n        } else {\n          this.$vs.notify({\n            title: 'Input Missing',\n            text: 'Title/Description cannot be empty',\n            color: 'primary'\n          });\n        }\n      } else {\n        this.$store.commit('TOGGLE_LOGIN_POPUP', true);\n      }\n    },\n    submitVideo() {\n      this.$Progress.start();\n      this.$vs.loading({ color: 'transparent' });\n      const video = this.$store.state.studio.video;\n      const metaData = this.$store.state.studio;\n      const sceneData = this.getSceneData(metaData);\n      const data = {\n        info: {\n          title: video.title,\n          description: video.description,\n          image: video.image,\n          script: metaData.videoScript,\n          url: video.url,\n          user: this.getUserName(),\n          duration: document.getElementById('preview_video').duration,\n          language: video.srcLang\n        },\n        id: this.videoId,\n        published_id: video.published_id,\n        scenes: sceneData,\n        bgm: metaData.backgroundMusic.url || null,\n        video: metaData.previewVideo,\n        is_save_later: this.saveForLater,\n        tags: metaData.tags\n      };\n      console.log(data);\n      /* Ajax call start */\n      this.$store\n        .dispatch('studio/publishVideo', data)\n        .then(res => {\n          if (!this.saveForLater) {\n            if (this.isPaid) {\n              const payload = {\n                exchange_key: video.txData.exchangeId,\n                dod: video.txData.did,\n                dataToken: video.txData.dataTokenAddress,\n                paid: video.isPaid,\n                video_id: res.data.id\n              };\n              this.$store\n                .dispatch('studio/postTxData', payload)\n                .then(() => {\n                  this.$Progress.finish();\n                  this.$vs.loading.close();\n                  this.$router.push('/dashboard');\n                  this.$vs.notify({\n                    title: 'Success',\n                    text: 'Video Published Successfully',\n                    color: 'success'\n                  });\n                })\n                .catch(err => {\n                  console.log(err);\n                  this.$Progress.fail();\n                  this.$vs.loading.close();\n                  this.$vs.notify({\n                    title: 'Error',\n                    text: 'Video Tx data was not saved',\n                    color: 'danger'\n                  });\n                });\n              return;\n            }\n            this.$Progress.finish();\n            this.$vs.loading.close();\n            this.$router.push('/dashboard');\n            this.$vs.notify({\n              title: 'Success',\n              text: 'Video Published Successfully',\n              color: 'success'\n            });\n          } else {\n            this.$Progress.finish();\n            this.$vs.loading.close();\n            this.$router.push('/myvideos');\n            this.$vs.notify({\n              title: 'Success',\n              text: 'Video Saved Successfully',\n              color: 'success'\n            });\n          }\n        })\n        .catch(err => {\n          console.log(err);\n          this.$Progress.fail();\n          this.$vs.loading.close();\n          this.$vs.notify({\n            title: 'Error',\n            text: this.saveForLater\n              ? 'Video was not saved'\n              : 'Video was not published',\n            color: 'danger'\n          });\n        });\n      /* Ajax call end */\n    },\n    getSceneData(metaData) {\n      const scenes = {};\n      Object.entries(metaData.scenes).forEach(([key, value]) => {\n        const {\n          sceneScriptColor: font_color,\n          sceneScriptPosition: position,\n          sceneBackgroundColor: background_color\n        } = metaData.styles[key];\n\n        scenes[key] = {\n          text: value,\n          keywords: metaData.keywords[key],\n          online_url: null,\n          audio: null,\n          uploaded_video: null,\n          position: position.toString(),\n          font_color,\n          background_color\n        };\n        // audio url\n        if (metaData.recordedAudios[key]) {\n          const audioUrl = metaData.recordedAudios[key];\n          scenes[key].audio = audioUrl.search('blob:') === -1 ? audioUrl : null;\n        }\n        // video url\n        if (metaData.selectedFromLibraryVideos[parseInt(key) + 1]) {\n          const videoUrl = new URL(\n            metaData.selectedFromLibraryVideos[parseInt(key) + 1]\n          );\n          if (videoUrl.origin === constants.apiUrl)\n            scenes[key].uploaded_video = videoUrl.href;\n          else scenes[key].online_url = videoUrl.href;\n        }\n      });\n      return scenes;\n    },\n    handleDownload() {\n      this.downloadInProgress = true;\n      this.$vs.loading({\n        background: 'primary',\n        color: '#fff',\n        container: '#download-with-loading',\n        scale: 0.45\n      });\n      axios\n        .get(this.getVideoLink, { responseType: 'blob' })\n        .then(response => {\n          const blob = new Blob([response.data], { type: 'video/mp4' });\n          const link = document.createElement('a');\n          link.href = URL.createObjectURL(blob);\n          link.download = this.getFilename;\n          link.click();\n          URL.revokeObjectURL(link.href);\n        })\n        .catch(() => {\n          this.$vs.notify({\n            title: 'Error Occured',\n            text: 'Download Failed',\n            color: 'danger'\n          });\n        })\n        .finally(() => {\n          this.downloadInProgress = false;\n          this.$vs.loading.close('#download-with-loading > .con-vs-loading');\n        });\n    }\n  },\n  beforeDestroy() {\n    clearTimeout(this.previewReq);\n  }\n};\n</script>\n\n<style scoped>\n.vs-con-loading__container {\n  z-index: 10 !important;\n}\n</style>\n"]}]}