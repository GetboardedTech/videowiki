"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Assets = exports.OrderProgressStep = exports.CreateProgressStep = void 0;
var DDO_1 = require("../ddo/DDO");
var DID_1 = __importDefault(require("./DID"));
var utils_1 = require("../utils");
var Instantiable_abstract_1 = require("../Instantiable.abstract");
var WebServiceConnector_1 = require("./utils/WebServiceConnector");
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var Provider_1 = require("../provider/Provider");
var web3_utils_1 = require("web3-utils");
var CreateProgressStep;
(function (CreateProgressStep) {
    CreateProgressStep[CreateProgressStep["CreatingDataToken"] = 0] = "CreatingDataToken";
    CreateProgressStep[CreateProgressStep["DataTokenCreated"] = 1] = "DataTokenCreated";
    CreateProgressStep[CreateProgressStep["EncryptingFiles"] = 2] = "EncryptingFiles";
    CreateProgressStep[CreateProgressStep["FilesEncrypted"] = 3] = "FilesEncrypted";
    CreateProgressStep[CreateProgressStep["StoringDdo"] = 4] = "StoringDdo";
    CreateProgressStep[CreateProgressStep["DdoStored"] = 5] = "DdoStored";
})(CreateProgressStep = exports.CreateProgressStep || (exports.CreateProgressStep = {}));
var OrderProgressStep;
(function (OrderProgressStep) {
    OrderProgressStep[OrderProgressStep["TransferDataToken"] = 0] = "TransferDataToken";
})(OrderProgressStep = exports.OrderProgressStep || (exports.OrderProgressStep = {}));
var Assets = (function (_super) {
    __extends(Assets, _super);
    function Assets() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Assets.getInstance = function (config) {
        return __awaiter(this, void 0, void 0, function () {
            var instance;
            return __generator(this, function (_a) {
                instance = new Assets();
                instance.setInstanceConfig(config);
                return [2, instance];
            });
        });
    };
    Assets.prototype.create = function (metadata, publisher, services, dtAddress, cap, name, symbol, providerUri) {
        var _this = this;
        if (services === void 0) { services = []; }
        if (dtAddress && !web3_utils_1.isAddress(dtAddress)) {
            this.logger.error("Passed Data Token address " + dtAddress + " is not valid. Aborting publishing.");
            return null;
        }
        this.logger.log('Creating asset');
        return new utils_1.SubscribablePromise(function (observer) { return __awaiter(_this, void 0, void 0, function () {
            var datatokens, did, provider, encryptedFiles, indexCount, ddo, _a, _b, storeTx;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (services.length === 0) {
                            this.logger.log('You have no services. Are you sure about this?');
                        }
                        datatokens = this.ocean.datatokens;
                        if (!!dtAddress) return [3, 2];
                        this.logger.log('Creating datatoken');
                        observer.next(CreateProgressStep.CreatingDataToken);
                        return [4, datatokens.create('', publisher.getId(), cap, name, symbol)];
                    case 1:
                        dtAddress = _d.sent();
                        if (!web3_utils_1.isAddress(dtAddress)) {
                            this.logger.error("Created Data Token address " + dtAddress + " is not valid. Aborting publishing.");
                            return [2, null];
                        }
                        this.logger.log("DataToken " + dtAddress + " created");
                        observer.next(CreateProgressStep.DataTokenCreated);
                        _d.label = 2;
                    case 2:
                        did = DID_1.default.generate(dtAddress);
                        this.logger.log('Encrypting files');
                        observer.next(CreateProgressStep.EncryptingFiles);
                        if (!providerUri) return [3, 5];
                        return [4, Provider_1.Provider.getInstance(this.instanceConfig)];
                    case 3:
                        provider = _d.sent();
                        return [4, provider.setBaseUrl(providerUri)];
                    case 4:
                        _d.sent();
                        return [3, 6];
                    case 5:
                        provider = this.ocean.provider;
                        _d.label = 6;
                    case 6: return [4, provider.encrypt(did.getDid(), metadata.main.files, publisher)];
                    case 7:
                        encryptedFiles = _d.sent();
                        this.logger.log('Files encrypted');
                        observer.next(CreateProgressStep.FilesEncrypted);
                        indexCount = 0;
                        ddo = new DDO_1.DDO({
                            id: did.getDid(),
                            dataToken: dtAddress,
                            authentication: [
                                {
                                    type: 'RsaSignatureAuthentication2018',
                                    publicKey: did.getDid()
                                }
                            ],
                            publicKey: [
                                {
                                    id: did.getDid(),
                                    type: 'EthereumECDSAKey',
                                    owner: publisher.getId()
                                }
                            ],
                            service: __spreadArray([
                                {
                                    type: 'metadata',
                                    attributes: __assign(__assign({ curation: {
                                            rating: 0,
                                            numVotes: 0
                                        } }, metadata), { encryptedFiles: encryptedFiles, main: __assign(__assign({}, metadata.main), { files: metadata.main.files.map(function (file, index) { return (__assign(__assign({}, file), { index: index, url: undefined })); }) }) })
                                }
                            ], services).reverse()
                                .filter(function (_a, i, list) {
                                var type = _a.type;
                                return list.findIndex(function (_a) {
                                    var t = _a.type;
                                    return t === type;
                                }) === i;
                            })
                                .reverse()
                                .map(function (_) { return (__assign(__assign({}, _), { index: indexCount++ })); })
                        });
                        return [4, ddo.addProof(this.ocean, publisher.getId())];
                    case 8:
                        _d.sent();
                        _a = ddo;
                        _c = {};
                        return [4, datatokens.getName(dtAddress)];
                    case 9:
                        _c.name = _d.sent();
                        return [4, datatokens.getSymbol(dtAddress)];
                    case 10:
                        _c.symbol = _d.sent(),
                            _c.address = dtAddress;
                        _b = parseFloat;
                        return [4, datatokens.getCap(dtAddress)];
                    case 11:
                        _a.dataTokenInfo = (_c.cap = _b.apply(void 0, [_d.sent()]),
                            _c);
                        this.logger.log('Storing DDO');
                        observer.next(CreateProgressStep.StoringDdo);
                        return [4, this.ocean.onChainMetadata.publish(ddo.id, ddo, publisher.getId())];
                    case 12:
                        storeTx = _d.sent();
                        this.logger.log('DDO stored ' + ddo.id);
                        observer.next(CreateProgressStep.DdoStored);
                        if (storeTx)
                            return [2, ddo];
                        else
                            return [2, null];
                        return [2];
                }
            });
        }); });
    };
    Assets.prototype.ownerAssets = function (owner) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.ocean.metadataCache.getOwnerAssets(owner)];
            });
        });
    };
    Assets.prototype.resolve = function (did) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.ocean.metadataCache.retrieveDDO(did)];
            });
        });
    };
    Assets.prototype.resolveByDTAddress = function (dtAddress, offset, page, sort) {
        return __awaiter(this, void 0, void 0, function () {
            var searchQuery;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        searchQuery = {
                            offset: offset || 100,
                            page: page || 1,
                            query: {
                                dataToken: [dtAddress]
                            },
                            sort: {
                                value: sort || 1
                            },
                            text: dtAddress
                        };
                        return [4, this.ocean.metadataCache.queryMetadata(searchQuery)];
                    case 1: return [2, (_a.sent()).results];
                }
            });
        });
    };
    Assets.prototype.editMetadata = function (ddo, newMetadata) {
        return __awaiter(this, void 0, void 0, function () {
            var i;
            return __generator(this, function (_a) {
                if (!ddo)
                    return [2, null];
                for (i = 0; i < ddo.service.length; i++) {
                    if (ddo.service[i].type !== 'metadata')
                        continue;
                    if (newMetadata.title)
                        ddo.service[i].attributes.main.name = newMetadata.title;
                    if (!ddo.service[i].attributes.additionalInformation)
                        ddo.service[i].attributes.additionalInformation = Object();
                    if (newMetadata.description)
                        ddo.service[i].attributes.additionalInformation.description =
                            newMetadata.description;
                    if (newMetadata.links) {
                        ddo.service[i].attributes.additionalInformation.links = newMetadata.links;
                    }
                    else {
                        ddo.service[i].attributes.additionalInformation.links = [];
                    }
                }
                return [2, ddo];
            });
        });
    };
    Assets.prototype.updateMetadata = function (ddo, consumerAccount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.ocean.onChainMetadata.update(ddo.id, ddo, consumerAccount)];
                    case 1: return [2, _a.sent()];
                }
            });
        });
    };
    Assets.prototype.editServiceTimeout = function (ddo, serviceIndex, timeout) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (!ddo)
                    return [2, null];
                if (typeof ddo.service[serviceIndex] === 'undefined')
                    return [2, null];
                if (timeout < 0)
                    return [2, null];
                ddo.service[serviceIndex].attributes.main.timeout = parseInt(timeout.toFixed());
                return [2, ddo];
            });
        });
    };
    Assets.prototype.creator = function (did) {
        return __awaiter(this, void 0, void 0, function () {
            var ddo, checksum, _a, creator, signatureValue, signer;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4, this.resolve(did)];
                    case 1:
                        ddo = _b.sent();
                        checksum = ddo.getChecksum();
                        _a = ddo.proof, creator = _a.creator, signatureValue = _a.signatureValue;
                        return [4, this.ocean.utils.signature.verifyText(checksum, signatureValue)];
                    case 2:
                        signer = _b.sent();
                        if (signer.toLowerCase() !== creator.toLowerCase()) {
                            this.logger.warn("Owner of " + ddo.id + " doesn't match. Expected " + creator + " instead of " + signer + ".");
                        }
                        return [2, creator];
                }
            });
        });
    };
    Assets.prototype.query = function (query) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.ocean.metadataCache.queryMetadata(query)];
            });
        });
    };
    Assets.prototype.search = function (text) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.ocean.metadataCache.queryMetadata({
                        text: text,
                        page: 1,
                        offset: 100,
                        query: {
                            value: 1
                        },
                        sort: {
                            value: 1
                        }
                    })];
            });
        });
    };
    Assets.prototype.getServiceByType = function (did, serviceType) {
        return __awaiter(this, void 0, void 0, function () {
            var service, services;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.resolve(did)];
                    case 1:
                        services = (_a.sent()).service;
                        services.forEach(function (serv) {
                            if (serv.type.toString() === serviceType) {
                                service = serv;
                            }
                        });
                        return [2, service];
                }
            });
        });
    };
    Assets.prototype.getServiceByIndex = function (did, serviceIndex) {
        return __awaiter(this, void 0, void 0, function () {
            var service, services;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.resolve(did)];
                    case 1:
                        services = (_a.sent()).service;
                        services.forEach(function (serv) {
                            if (serv.index === serviceIndex) {
                                service = serv;
                            }
                        });
                        return [2, service];
                }
            });
        });
    };
    Assets.prototype.createAccessServiceAttributes = function (creator, cost, datePublished, timeout, providerUri) {
        if (timeout === void 0) { timeout = 0; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, {
                        type: 'access',
                        index: 2,
                        serviceEndpoint: providerUri || this.ocean.provider.url,
                        attributes: {
                            main: {
                                creator: creator.getId(),
                                datePublished: datePublished,
                                cost: cost,
                                timeout: timeout,
                                name: 'dataAssetAccess'
                            }
                        }
                    }];
            });
        });
    };
    Assets.prototype.initialize = function (did, serviceType, consumerAddress, serviceIndex, serviceEndpoint) {
        if (serviceIndex === void 0) { serviceIndex = -1; }
        return __awaiter(this, void 0, void 0, function () {
            var provider, res, providerData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, Provider_1.Provider.getInstance(this.instanceConfig)];
                    case 1:
                        provider = _a.sent();
                        return [4, provider.setBaseUrl(serviceEndpoint)];
                    case 2:
                        _a.sent();
                        return [4, provider.initialize(did, serviceIndex, serviceType, consumerAddress)];
                    case 3:
                        res = _a.sent();
                        if (res === null)
                            return [2, null];
                        providerData = JSON.parse(res);
                        return [2, providerData];
                }
            });
        });
    };
    Assets.prototype.order = function (did, serviceType, payerAddress, serviceIndex, mpAddress, consumerAddress, searchPreviousOrders) {
        if (serviceIndex === void 0) { serviceIndex = -1; }
        if (searchPreviousOrders === void 0) { searchPreviousOrders = true; }
        return __awaiter(this, void 0, void 0, function () {
            var service, providerData, previousOrder, balance, _a, totalCost, txid, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!consumerAddress)
                            consumerAddress = payerAddress;
                        if (!(serviceIndex === -1)) return [3, 2];
                        return [4, this.getServiceByType(did, serviceType)];
                    case 1:
                        service = _b.sent();
                        serviceIndex = service.index;
                        return [3, 4];
                    case 2: return [4, this.getServiceByIndex(did, serviceIndex)];
                    case 3:
                        service = _b.sent();
                        serviceType = service.type;
                        _b.label = 4;
                    case 4:
                        _b.trys.push([4, 10, , 11]);
                        return [4, this.initialize(did, serviceType, payerAddress, serviceIndex, service.serviceEndpoint)];
                    case 5:
                        providerData = _b.sent();
                        if (!providerData)
                            return [2, null];
                        if (!searchPreviousOrders) return [3, 7];
                        return [4, this.ocean.datatokens.getPreviousValidOrders(providerData.dataToken, providerData.numTokens, serviceIndex, service.attributes.main.timeout, consumerAddress)];
                    case 6:
                        previousOrder = _b.sent();
                        if (previousOrder)
                            return [2, previousOrder];
                        _b.label = 7;
                    case 7:
                        _a = bignumber_js_1.default.bind;
                        return [4, this.ocean.datatokens.balance(providerData.dataToken, payerAddress)];
                    case 8:
                        balance = new (_a.apply(bignumber_js_1.default, [void 0, _b.sent()]))();
                        totalCost = new bignumber_js_1.default(String(providerData.numTokens));
                        if (balance.isLessThan(totalCost)) {
                            this.logger.error('ERROR: Not enough funds Needed ' +
                                totalCost.toString() +
                                ' but balance is ' +
                                balance.toString());
                            return [2, null];
                        }
                        return [4, this.ocean.datatokens.startOrder(providerData.dataToken, consumerAddress, String(providerData.numTokens), serviceIndex, mpAddress, payerAddress)];
                    case 9:
                        txid = _b.sent();
                        if (txid)
                            return [2, txid.transactionHash];
                        return [3, 11];
                    case 10:
                        e_1 = _b.sent();
                        this.logger.error("ERROR: Failed to order: " + e_1.message);
                        return [3, 11];
                    case 11: return [2, null];
                }
            });
        });
    };
    Assets.prototype.download = function (did, txId, tokenAddress, consumerAccount, destination) {
        return __awaiter(this, void 0, void 0, function () {
            var ddo, attributes, service, files, serviceEndpoint, provider;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.resolve(did)];
                    case 1:
                        ddo = _a.sent();
                        attributes = ddo.findServiceByType('metadata').attributes;
                        service = ddo.findServiceByType('access');
                        files = attributes.main.files;
                        serviceEndpoint = service.serviceEndpoint;
                        if (!serviceEndpoint) {
                            throw new Error('Consume asset failed, service definition is missing the `serviceEndpoint`.');
                        }
                        this.logger.log('Consuming files');
                        destination = destination
                            ? destination + "/datafile." + ddo.shortId() + "." + service.index + "/"
                            : undefined;
                        return [4, Provider_1.Provider.getInstance(this.instanceConfig)];
                    case 2:
                        provider = _a.sent();
                        return [4, provider.setBaseUrl(serviceEndpoint)];
                    case 3:
                        _a.sent();
                        return [4, provider.download(did, txId, tokenAddress, service.type, service.index.toString(), destination, consumerAccount, files)];
                    case 4:
                        _a.sent();
                        return [2, true];
                }
            });
        });
    };
    Assets.prototype.simpleDownload = function (dtAddress, serviceEndpoint, txId, account) {
        return __awaiter(this, void 0, void 0, function () {
            var consumeUrl, serviceConnector, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        consumeUrl = serviceEndpoint;
                        consumeUrl += "?consumerAddress=" + account;
                        consumeUrl += "&tokenAddress=" + dtAddress;
                        consumeUrl += "&transferTxId=" + txId;
                        serviceConnector = new WebServiceConnector_1.WebServiceConnector(this.logger);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4, serviceConnector.downloadFile(consumeUrl)];
                    case 2:
                        _a.sent();
                        return [3, 4];
                    case 3:
                        e_2 = _a.sent();
                        this.logger.error('Error consuming assets');
                        this.logger.error(e_2);
                        throw e_2;
                    case 4: return [2, serviceEndpoint];
                }
            });
        });
    };
    Assets.prototype.getOrderHistory = function (account, serviceType, fromBlock) {
        return __awaiter(this, void 0, void 0, function () {
            var results, address, datatokens, topic1, topic0, events, i, order, params, service, e_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        results = [];
                        address = account.getId().toLowerCase();
                        datatokens = this.ocean.datatokens;
                        topic1 = '0x000000000000000000000000' + address.substring(2);
                        topic0 = datatokens.getStartOrderEventSignature();
                        return [4, this.web3.eth.getPastLogs({
                                topics: [topic0, null, topic1],
                                fromBlock: fromBlock || 0,
                                toBlock: 'latest'
                            })];
                    case 1:
                        events = _a.sent();
                        i = 0;
                        _a.label = 2;
                    case 2:
                        if (!(i < events.length)) return [3, 7];
                        order = {
                            dtAddress: events[i].address,
                            timestamp: 0,
                            transactionHash: events[i].transactionHash,
                            amount: null,
                            consumer: '0x' + events[i].topics[1].substring(events[i].topics[1].length - 40),
                            payer: '0x' + events[i].topics[2].substring(events[i].topics[2].length - 40)
                        };
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        params = this.web3.eth.abi.decodeParameters(['uint256', 'uint256', 'uint256', 'uint256'], events[i].data);
                        order.serviceId = parseInt(params[1]);
                        order.timestamp = parseInt(params[2]);
                        order.amount = this.web3.utils.fromWei(params[0]);
                        order.did = utils_1.didPrefixed(utils_1.didNoZeroX(order.dtAddress));
                        return [4, this.getServiceByIndex(order.did, order.serviceId)];
                    case 4:
                        service = _a.sent();
                        order.serviceType = service.type;
                        if (!serviceType || (serviceType && serviceType === service.type))
                            results.push(order);
                        return [3, 6];
                    case 5:
                        e_3 = _a.sent();
                        return [3, 6];
                    case 6:
                        i++;
                        return [3, 2];
                    case 7: return [2, results];
                }
            });
        });
    };
    return Assets;
}(Instantiable_abstract_1.Instantiable));
exports.Assets = Assets;
//# sourceMappingURL=Assets.js.map