import { DDO } from '../ddo/DDO';
import { MetadataAlgorithm } from '../ddo/interfaces/MetadataAlgorithm';
import { ServiceComputePrivacy, ServiceCompute, publisherTrustedAlgorithm } from '../ddo/interfaces/Service';
import Account from './Account';
import { SubscribablePromise } from '../utils';
import { Instantiable, InstantiableConfig } from '../Instantiable.abstract';
import { Output } from './interfaces/ComputeOutput';
import { ComputeJob } from './interfaces/ComputeJob';
import { ComputeInput } from './interfaces/ComputeInput';
export declare enum OrderProgressStep {
    TransferDataToken = 0
}
export interface Cluster {
    type: string;
    url: string;
}
export interface Container {
    image: string;
    tag: string;
    checksum: string;
}
export interface Server {
    serverId: string;
    serverType: string;
    cost: string;
    cpu: string;
    gpu: string;
    memory: string;
    disk: string;
    maxExecutionTime: number;
}
export declare const ComputeJobStatus: Readonly<{
    WarmingUp: number;
    Started: number;
    ConfiguringVolumes: number;
    ProvisioningSuccess: number;
    DataProvisioningFailed: number;
    AlgorithmProvisioningFailed: number;
    RunningAlgorithm: number;
    FilteringResults: number;
    PublishingResult: number;
    Completed: number;
    Stopped: number;
    Deleted: number;
}>;
export declare class Compute extends Instantiable {
    static getInstance(config: InstantiableConfig): Promise<Compute>;
    getComputeAddress(did: string, serviceIndex?: number): Promise<string>;
    start(did: string, txId: string, tokenAddress: string, consumerAccount: Account, algorithmDid?: string, algorithmMeta?: MetadataAlgorithm, output?: Output, serviceIndex?: string, serviceType?: string, algorithmTransferTxId?: string, algorithmDataToken?: string, additionalInputs?: ComputeInput[]): Promise<ComputeJob>;
    stop(consumerAccount: Account, did: string, jobId: string): Promise<ComputeJob>;
    delete(consumerAccount: Account, did: string, jobId: string): Promise<ComputeJob>;
    status(consumerAccount: Account, did?: string, jobId?: string, txId?: string, sign?: boolean): Promise<ComputeJob[]>;
    result(consumerAccount: Account, did: string, jobId: string): Promise<ComputeJob>;
    createServerAttributes(serverId: string, serverType: string, cost: string, cpu: string, gpu: string, memory: string, disk: string, maxExecutionTime: number): Server;
    createContainerAttributes(image: string, tag: string, checksum: string): Container;
    createClusterAttributes(type: string, url: string): Cluster;
    createProviderAttributes(type: string, description: string, cluster: Cluster, containers: Container[], servers: Server[]): {
        type: string;
        description: string;
        environment: {
            cluster: Cluster;
            supportedServers: Server[];
            supportedContainers: Container[];
        };
    };
    createComputeService(consumerAccount: Account, cost: string, datePublished: string, providerAttributes: any, computePrivacy?: ServiceComputePrivacy, timeout?: number, providerUri?: string): ServiceCompute;
    private checkOutput;
    isOrderable(datasetDid: string, serviceIndex: number, algorithmDid?: string, algorithmMeta?: MetadataAlgorithm): Promise<boolean>;
    orderAsset(consumerAccount: string, datasetDid: string, serviceIndex: number, algorithmDid?: string, algorithmMeta?: MetadataAlgorithm, mpAddress?: string, computeAddress?: string): SubscribablePromise<OrderProgressStep, string>;
    orderAlgorithm(did: string, serviceType: string, payerAddress: string, serviceIndex?: number, mpAddress?: string, consumerAddress?: string, searchPreviousOrders?: boolean): Promise<string>;
    editComputePrivacy(ddo: DDO, serviceIndex: number, computePrivacy: ServiceComputePrivacy): Promise<DDO>;
    createPublisherTrustedAlgorithmfromDID(did: string, ddo?: DDO): Promise<publisherTrustedAlgorithm>;
    addTrustedAlgorithmtoAsset(ddo: DDO, serviceIndex: number, algoDid: string): Promise<DDO>;
    isAlgorithmTrusted(ddo: DDO, serviceIndex: number, algoDid: string): Promise<boolean>;
    removeTrustedAlgorithmFromAsset(ddo: DDO, serviceIndex: number, algoDid: string): Promise<DDO>;
}
