import { SearchQuery, QueryResult } from '../metadatacache/MetadataCache';
import { DDO } from '../ddo/DDO';
import { Metadata } from '../ddo/interfaces/Metadata';
import { Service, ServiceAccess } from '../ddo/interfaces/Service';
import { EditableMetadata } from '../ddo/interfaces/EditableMetadata';
import Account from './Account';
import { SubscribablePromise } from '../utils';
import { Instantiable, InstantiableConfig } from '../Instantiable.abstract';
import { TransactionReceipt } from 'web3-core';
export declare enum CreateProgressStep {
    CreatingDataToken = 0,
    DataTokenCreated = 1,
    EncryptingFiles = 2,
    FilesEncrypted = 3,
    StoringDdo = 4,
    DdoStored = 5
}
export declare enum OrderProgressStep {
    TransferDataToken = 0
}
export interface Order {
    dtAddress: string;
    amount: string;
    timestamp: number;
    transactionHash: string;
    consumer: string;
    payer: string;
    did?: string;
    serviceId?: number;
    serviceType?: string;
}
export declare class Assets extends Instantiable {
    static getInstance(config: InstantiableConfig): Promise<Assets>;
    create(metadata: Metadata, publisher: Account, services?: Service[], dtAddress?: string, cap?: string, name?: string, symbol?: string, providerUri?: string): SubscribablePromise<CreateProgressStep, DDO>;
    ownerAssets(owner: string): Promise<QueryResult>;
    resolve(did: string): Promise<DDO>;
    resolveByDTAddress(dtAddress: string, offset?: number, page?: number, sort?: number): Promise<DDO[]>;
    editMetadata(ddo: DDO, newMetadata: EditableMetadata): Promise<DDO>;
    updateMetadata(ddo: DDO, consumerAccount: string): Promise<TransactionReceipt>;
    editServiceTimeout(ddo: DDO, serviceIndex: number, timeout: number): Promise<DDO>;
    creator(did: string): Promise<string>;
    query(query: SearchQuery): Promise<QueryResult>;
    search(text: string): Promise<QueryResult>;
    getServiceByType(did: string, serviceType: string): Promise<Service>;
    getServiceByIndex(did: string, serviceIndex: number): Promise<Service>;
    createAccessServiceAttributes(creator: Account, cost: string, datePublished: string, timeout?: number, providerUri?: string): Promise<ServiceAccess>;
    initialize(did: string, serviceType: string, consumerAddress: string, serviceIndex: number, serviceEndpoint: string): Promise<any>;
    order(did: string, serviceType: string, payerAddress: string, serviceIndex?: number, mpAddress?: string, consumerAddress?: string, searchPreviousOrders?: boolean): Promise<string>;
    download(did: string, txId: string, tokenAddress: string, consumerAccount: Account, destination: string): Promise<string | true>;
    simpleDownload(dtAddress: string, serviceEndpoint: string, txId: string, account: string): Promise<string>;
    getOrderHistory(account: Account, serviceType?: string, fromBlock?: number): Promise<Order[]>;
}
